<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geocode Addresses by Map Extent</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.31/esri/themes/light/main.css">
  <script src="https://js.arcgis.com/4.31/"></script>
  <style>
    html,
    body,
    #viewDiv {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #geocodeButton {
      position: absolute;
      top: 10px;
      left: 250px;
      z-index: 99;
      background-color: white;
      padding: 10px;
      border: 1px solid #ccc;
      cursor: pointer;
    }

    #topPanel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 99;
      background-color: white;
      padding: 10px 20px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: 'Arial', sans-serif;
      font-weight: bold;
      font-size: 16px;
    }

    #jobIdDisplay {
      margin-left: 3%;
    }

    .dropdown {
      margin-right: 110px;
      padding: 5px;
      border-radius: 5px;
      font-family: 'Arial', sans-serif;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
    }

    .vexButton {
      margin-left: 1500px;
      padding: 5px;
      border-radius: 5px;
      font-family: 'Arial', sans-serif;
      font-weight: bold;
      font-size: 16px;
    }

    .vexcelMapContainer {
      position: absolute;
      top: 50px;
      right: 20%;
      bottom: 400px;
      background-color: white;
      display: block;
    }

    #vexcelMap {
      position: absolute;
      top: 150px;
      left: 0;
      right: 0;
      bottom: 0;
    }

    #vexcelMapContainer {
      position: absolute;
      top: 50px;
      width: 500px;
      height: 600px;
      right: 20%;
      border-color: #555;
      border-width: 1cm;
    }

    #orientationButtons {
      margin-top: 20px;
      margin-left: 50px;
      font-weight: bold;
      font-size: 14;
    }

    #rightPanel {
      position: fixed;
      top: 65px;
      right: 0;
      width: 20%;
      height: calc(100% - 50px);
      background-color: white;
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      font-family: 'Arial', sans-serif;
    }

    #editToolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 99;
      background-color: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    #layerListDiv {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 99;
      background-color: white;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    #cognizantLogo {
      height: 40px;
      margin-left: 20px;
      padding-right: 50px;
    }
  </style>
  <link rel="stylesheet" href="https://app.vexcelgroup.com/map/latest/public/css/styles.css" type="text/css" />
  <script type="text/javascript" src="https://app.vexcelgroup.com/map/latest/public/Vexcel.js"></script>
</head>

<body>
  <div id="topPanel">
    <div id="jobIdDisplay"></div>
    <select class="dropdown" id="3dSelect">
      <option value="3D OFF">3D OFF</option>
      <option value="3D ON">3D ON</option>
    </select>
    <img id="cognizantLogo" src="https://cognizant.scene7.com/is/content/cognizant/COG-Logo-2022-1?fmt=png-alpha"
      alt="Cognizant Logo" />
  </div>
  <div id="viewDiv"></div>
  <button id="geocodeButton">Geocode Extent</button>
  <div class="vexcelMapContainer" id="vexcelMapContainer">
    <div id="vexcelMap" class="vexcelMap"></div>
    <div class="orientationButtons" style="margin-top: 20px;margin-left: 20px;font-weight: bold;font-size: 14">
      <button id="closeBtn" style="margin-right:20px;">X</button>
      <button id="verticalBtn">Vertical</button>
      <button id="northBtn">North</button>
      <button id="southBtn">South</button>
      <button id="eastBtn">East</button>
      <button id="westBtn">West</button>
      <button id="dragBtn" style="margin-left:20px;">Drag</button>
      <br><br>
      <div class="col-md-3">
        <button id="point">Point</button>
        <button id="line">Line</button>
        <button id="polygon">Polygon</button>
        <button id="rectangle">Rectangle</button>
        <button id="circle">Circle</button>
      </div>
    </div>
  </div>
  <div id="rightPanel"></div>
  <script>
    require([
      "esri/config",
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/FeatureLayer",
      "esri/geometry/Extent",
      "esri/core/urlUtils",
      "esri/widgets/LayerList",
      "esri/widgets/Editor",
      "esri/layers/MapImageLayer",
      "esri/geometry/support/webMercatorUtils",
      "esri/widgets/Search",
      "esri/Graphic",
      "esri/geometry/projection",
      "esri/layers/GraphicsLayer",
      "esri/layers/ImageryLayer",
      "esri/geometry/Point",
      "esri/layers/TileLayer",
      "esri/widgets/Sketch",
      "esri/layers/GraphicsLayer",
      "esri/Graphic"
    ], function (esriConfig, Map, MapView, FeatureLayer, Extent, urlUtils, LayerList, Editor, MapImageLayer, webMercatorUtils, Search, Graphic, projection, GraphicsLayer, ImageryLayer, Point, TileLayer, Sketch, GraphicsLayer, Graphic) {
      hideVexcelMap();

      const urlParams = new URLSearchParams(window.location.search);
      const jobId = urlParams.get('jobId');
      const token = sessionStorage.getItem("authToken");
      const map = new Map({
        basemap: "topo"
      });
      const view = new MapView({
        container: "viewDiv",
        map: map,
        center: [-104.993874, 39.754711],
        zoom: 19
      });
      const searchWidget = new Search({
        view: view
      });
      view.ui.add(searchWidget, {
        position: "top-left"
      });
      const editor = new Editor({
        view: view
      });
      view.ui.add(editor, {
        position: "top-left"
      });
      const vexcel_1520 = new ImageryLayer({
        url: 'https://gis.apfo.usda.gov/arcgis/rest/services/NAIP/USDA_CONUS_PRIME/ImageServer'
      });
      map.addMany([vexcel_1520]);
      const graphicsLayer = new GraphicsLayer();
      map.add(graphicsLayer);
      const toolButton = document.createElement("button");
      toolButton.id = "toolButton";
      toolButton.textContent = "Activate Object Detection Tool";
      toolButton.style.position = "absolute";
      toolButton.style.top = "10px";
      toolButton.style.left = "10px";
      toolButton.style.zIndex = "99";
      document.body.appendChild(toolButton);

      // Object Detection Panel
      const ObjectDetectionPanel = class {
        constructor(view, detectionParameters, sendObjectDetectionRequest) {
          this.view = view;
          this.detectionParameters = detectionParameters;
          this.textPrompt = '';
          this.zoomLevel = view.zoom;
          this.boxThreshold = 0.24;
          this.textThreshold = 0.24;
          this.opacity = 0.9;
          this.color = '#3333CC';
          this.geoJsonData = null;
          this.panelVisible = false;
          this.sendRequest = sendObjectDetectionRequest;
          this.displayMode = 'segments';
          this.editableLayer = null;
          this.includePoints = [];
          this.excludePoints = [];
          this.pointsLayer = new GraphicsLayer();
          this.pointsColor = '#3333CC';
          this.pointsOpacity = 0.9;
          this.pointsDisplayMode = 'segments';
          this.currentMode = null;
          this.deleteMode = false;
          view.map.add(this.pointsLayer);
          this.createPanel();
          this.setupEventListeners();
        }

        createPanel() {
          this.panel = document.createElement('div');
          this.panel.className = 'object-detection-panel';
          this.panel.style.display = 'none';

          this.panel.innerHTML = `
            <div class="panel-header">
              <h3>Object Detection</h3>
              <button type="button" class="close-btn">Ã—</button>
            </div>
            
            <div class="tab-container">
              <div class="tab-buttons">
                <button class="tab-btn active" data-tab="text">Text Prompt</button>
                <button class="tab-btn" data-tab="points">Point Prompt</button>
              </div>
              
              <div class="tab-content">
                <!-- Text Prompt Tab -->
                <div class="tab-pane active" id="text-tab">
                  <div class="panel-content">
                    <div class="input-group">
                      <label for="text-prompt">What do you want to detect?</label>
                      <input type="text" id="text-prompt" placeholder="e.g., poles, trees, buildings">
                    </div>
                    
                    <div class="input-group">
                      <label for="box-threshold">Box Threshold: <span id="box-threshold-value">0.24</span></label>
                      <input type="range" id="box-threshold" min="0" max="1" step="0.01" value="0.24">
                    </div>

                    <div class="input-group">
                      <label for="text-threshold">Text Threshold: <span id="text-threshold-value">0.24</span></label>
                      <input type="range" id="text-threshold" min="0" max="1" step="0.01" value="0.24">
                    </div>

                    <div class="input-group">
                      <label for="zoom-level">Zoom Level</label>
                      <select id="zoom-level">
                        ${[19, 20, 21, 22].map(zoom =>
                          `<option value="${zoom}">${zoom}</option>`
                        ).join('')}
                      </select>
                    </div>

                    <div class="input-group">
                      <label>Display Options:</label>
                      <div class="radio-group">
                        <input type="radio" id="display-segments" name="display-mode" value="segments" checked>
                        <label for="display-segments">Polygons</label>
                        
                        <input type="radio" id="display-centroids" name="display-mode" value="centroids">
                        <label for="display-centroids">Centroids</label>
                      </div>
                    </div>

                    <div class="input-group">
                      <label for="opacity">Opacity: <span id="opacity-value">0.9</span></label>
                      <input type="range" id="opacity" min="0" max="1" step="0.1" value="0.9">
                    </div>

                    <div class="input-group">
                      <label for="color-picker">Color:</label>
                      <input type="color" id="color-picker" value="#3333CC">
                    </div>

                    <div class="instruction">
                      <span>Draw a rectangle to start</span>
                    </div>
                    <div id='sketch_container'></div>
                    
                    <button type="button" id="detect-btn" class="detect-button">
                      Detect Objects
                    </button>

                    <button type="button" id="reset-btn" class="reset-button">
                      Reset Settings
                    </button>
                  </div>
                </div>

                <!-- Point Prompt Tab -->
                <div class="tab-pane" id="points-tab">
                  <div class="panel-content">                    
                    <div class="input-group">
                      <label for="points-box-threshold">Box Threshold: <span id="points-box-threshold-value">0.24</span></label>
                      <input type="range" id="points-box-threshold" 
                             min="0" max="1" step="0.01" value="0.24">
                    </div>

                    <div class="input-group">
                      <label for="points-zoom-level">Zoom Level:</label>
                      <select id="points-zoom-level">
                        <option value="19">19</option>
                        <option value="20">20</option>
                        <option value="21">21</option>
                        <option value="22" selected>22</option>
                      </select>
                    </div>

                    <div class="input-group">
                      <label>Add points to start:</label>
                      <div class="button-group">
                        <button id="includeMode" class="mode-button">Add Include Points</button>
                        <button id="excludeMode" class="mode-button">Add Exclude Points</button>
                        <button id="deleteMode" class="mode-button">Delete Points</button>
                      </div>
                    </div>

                    <div class="input-group">
                      <label>Display Options:</label>
                      <div class="radio-group">
                        <input type="radio" id="points-display-segments" name="points-display-mode" value="segments" checked>
                        <label for="points-display-segments">Polygons</label>
                        
                        <input type="radio" id="points-display-centroids" name="points-display-mode" value="centroids">
                        <label for="points-display-centroids">Centroids</label>
                      </div>
                    </div>

                    <div class="input-group">
                      <label for="points-opacity">Opacity: <span id="points-opacity-value">0.9</span></label>
                      <input type="range" id="points-opacity" min="0" max="1" step="0.1" value="0.9">
                    </div>

                    <div class="input-group">
                      <label for="points-color-picker">Color:</label>
                      <input type="color" id="points-color-picker" value="#3333CC">
                    </div>

                    <div class="instruction">
                      <span>Click on map to add points</span>
                    </div>

                    <button type="button" id="points-detect" class="detect-button">
                      Detect Objects
                    </button>

                    <button type="button" id="points-reset" class="reset-button">
                      Reset Settings
                    </button>
                  </div>
                </div>
              </div>
            </div>
          `;

          document.body.appendChild(this.panel);
          this.addStyles();
        }

        addStyles() {
          const style = document.createElement('style');
          style.textContent = `
            .hide{
              display: none;
            }
            .object-detection-panel {
              position: absolute;
              top: 10px;
              left: 10px;
              width: 300px;
              background: white;
              border-radius: 4px;
              box-shadow: 0 2px 4px rgba(0,0,0,0.2);
              z-index: 1000;
              font-family: Arial, sans-serif;
            }
            
            .panel-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              padding: 10px 15px;
              border-bottom: 1px solid #eee;
            }
            
            .panel-header h3 {
              margin: 0;
              font-size: 16px;
            }
            
            .close-btn {
              background: none;
              border: none;
              font-size: 20px;
              cursor: pointer;
              padding: 0 5px;
            }
            
            .panel-content {
              padding: 15px;
            }
            
            .input-group {
              margin-bottom: 15px;
            }
                    
            .radio-group {
              display: flex;
              gap: 15px;
              margin-top: 5px;
              width: 50px;
            }

            .radio-group input[type="radio"] {
              width: 12px;
            }

            .radio-group label {
              display: inline;
              margin-bottom: 0;
            }

            .input-group label {
              display: block;
              margin-bottom: 5px;
              font-size: 14px;
            }
            
            .input-group input,
            .input-group select {
              width: 80%;
              padding: 8px;
              border: 1px solid #ddd;
              border-radius: 4px;
              font-size: 14px;
            }
            
            .instruction {
              margin: 10px 0;
              font-size: 14px;
              color: #666;
            }
            
            .detect-button {
              width: 100%;
              padding: 10px;
              background: #1976d2;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 14px;
            }
            
            .detect-button:disabled {
              background: #ccc;
              cursor: not-allowed;
            }
            
            .detect-button.loading {
              position: relative;
              color: transparent;
            }
            
            .detect-button.loading::after {
              content: '';
              position: absolute;
              width: 16px;
              height: 16px;
              top: 50%;
              left: 50%;
              margin: -8px 0 0 -8px;
              border: 2px solid #fff;
              border-radius: 50%;
              border-right-color: transparent;
              animation: spin 0.75s linear infinite;
            }
            
            @keyframes spin {
              100% { transform: rotate(360deg); }
            }
            
            .toggle-request-btn {
              margin-top: 10px;
              background: none;
              border: 1px solid #ddd;
              padding: 5px 10px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
            }
            
            .request-body {
              margin-top: 10px;
              padding: 10px;
              background: #f5f5f5;
              border-radius: 4px;
              font-size: 12px;
              white-space: pre-wrap;
              max-height: 200px;
              overflow: auto;
            }

            .reset-button {
              width: 100%;
              padding: 10px;
              background: #f44336;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 14px;
              margin-top: 10px;
            }

            input[type="range"] {
              width: 80%;
              margin: 10px 0;
            }

            input[type="color"] {
              width: 50px;
              height: 30px;
              padding: 0;
              border: none;
              border-radius: 4px;
              cursor: pointer;
            }

            .tab-container {
              width: 100%;
            }

            .tab-buttons {
              display: flex;
              border-bottom: 1px solid #ddd;
              margin-bottom: 15px;
            }

            .tab-btn {
              padding: 10px 20px;
              border: none;
              background: none;
              cursor: pointer;
              font-size: 14px;
              font-weight: bold;
              color: #666;
            }

            .tab-btn.active {
              color: #1976d2;
              border-bottom: 2px solid #1976d2;
            }

            .tab-content {
              padding: 10px;
            }

            .tab-pane {
              display: none;
            }

            .tab-pane.active {
              display: block;
            }

            .mode-button {
              padding: 8px 15px;
              margin: 5px;
              border: 1px solid #ddd;
              border-radius: 4px;
              background-color: white;
              cursor: pointer;
            }

            .mode-button.active {
              background-color: #1976d2;
              color: white;
              border-color: #1976d2;
            }

            .mode-button.delete-mode {
              background-color: #ff4444;
              color: white;
              border-color: #ff4444;
            }
          `;
          document.head.appendChild(style);
        }

        setupEventListeners() {
          // Close button
          this.panel.querySelector('.close-btn').addEventListener('click', () => {
            this.hide();
          });

          // Text prompt input
          const textPromptInput = this.panel.querySelector('#text-prompt');
          textPromptInput.addEventListener('input', (e) => {
            this.textPrompt = e.target.value;
          });

          // Zoom level select
          const zoomLevelSelect = this.panel.querySelector('#zoom-level');
          zoomLevelSelect.value = this.zoomLevel;
          zoomLevelSelect.addEventListener('change', (e) => {
            this.zoomLevel = parseInt(e.target.value);
          });

          // Detect button
          const detectButton = this.panel.querySelector('#detect-btn');
          detectButton.addEventListener('click', (e) => {
            e.stopPropagation();
            this.handleDetect();
          });

          // Box threshold slider
          const boxThresholdInput = this.panel.querySelector('#box-threshold');
          const boxThresholdValue = this.panel.querySelector('#box-threshold-value');
          boxThresholdInput.addEventListener('input', (e) => {
            this.boxThreshold = parseFloat(e.target.value);
            boxThresholdValue.textContent = this.boxThreshold.toFixed(2);
          });

          // Text threshold slider
          const textThresholdInput = this.panel.querySelector('#text-threshold');
          const textThresholdValue = this.panel.querySelector('#text-threshold-value');
          textThresholdInput.addEventListener('input', (e) => {
            this.textThreshold = parseFloat(e.target.value);
            textThresholdValue.textContent = this.textThreshold.toFixed(2);
          });

          // Opacity slider
          const opacityInput = this.panel.querySelector('#opacity');
          const opacityValue = this.panel.querySelector('#opacity-value');
          opacityInput.addEventListener('input', (e) => {
            this.opacity = parseFloat(e.target.value);
            opacityValue.textContent = this.opacity.toFixed(1);
            if (this.geoJsonData) {
              this.updateGeoJsonStyle();
            }
          });

          // Color picker
          const colorPicker = this.panel.querySelector('#color-picker');
          colorPicker.addEventListener('input', (e) => {
            this.color = e.target.value;
            if (this.geoJsonData) {
              this.updateGeoJsonStyle();
            }
          });

          // Reset button
          const resetButton = this.panel.querySelector('#reset-btn');
          resetButton.addEventListener('click', () => {
            this.resetSettings();
          });

          // Display mode radio buttons
          const displayModeInputs = this.panel.querySelectorAll('input[name="display-mode"]');
          displayModeInputs.forEach(input => {
            input.addEventListener('change', (e) => {
              this.displayMode = e.target.value;
              if (this.geoJsonData) {
                this.updateDisplay();
              }
            });
          });

          // Tab switching
          const tabButtons = this.panel.querySelectorAll('.tab-btn');
          tabButtons.forEach(button => {
            button.addEventListener('click', () => {
              // Remove active class from all buttons and panes
              tabButtons.forEach(btn => btn.classList.remove('active'));
              this.panel.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
              
              // Add active class to clicked button and corresponding pane
              button.classList.add('active');
              const tabId = button.dataset.tab;
              this.panel.querySelector(`#${tabId}-tab`).classList.add('active');
            });
          });

          // Points tab specific event listeners
          const updateButtonStates = () => {
            const includeButton = this.panel.querySelector('#includeMode');
            const excludeButton = this.panel.querySelector('#excludeMode');
            const deleteButton = this.panel.querySelector('#deleteMode');

            includeButton.className = `mode-button ${this.currentMode === 'include' ? 'active' : ''}`;
            excludeButton.className = `mode-button ${this.currentMode === 'exclude' ? 'active' : ''}`;
            deleteButton.className = `mode-button ${this.deleteMode ? 'delete-mode' : ''}`;
          };

          // Points opacity slider
          const pointsOpacityInput = this.panel.querySelector('#points-opacity');
          const pointsOpacityValue = this.panel.querySelector('#points-opacity-value');
          pointsOpacityInput.addEventListener('input', (e) => {
            this.pointsOpacity = parseFloat(e.target.value);
            pointsOpacityValue.textContent = this.pointsOpacity.toFixed(1);
            this.updatePointsStyle();
          });

          // Points color picker
          const pointsColorPicker = this.panel.querySelector('#points-color-picker');
          pointsColorPicker.addEventListener('input', (e) => {
            this.pointsColor = e.target.value;
            this.updatePointsStyle();
          });

          // Points display mode
          const pointsDisplayModeInputs = this.panel.querySelectorAll('input[name="points-display-mode"]');
          pointsDisplayModeInputs.forEach(input => {
            input.addEventListener('change', (e) => {
              this.pointsDisplayMode = e.target.value;
              this.updatePointsDisplay();
            });
          });

          // Add click handler for points
          this.view.on("click", (event) => {
            // Only handle clicks when points tab is active
            if (!this.panelVisible || !this.panel.querySelector('#points-tab').classList.contains('active')) {
              return;
            }

            event.stopPropagation();

            if (this.deleteMode) {
              // Delete point logic
              const screenPoint = {
                x: event.x,
                y: event.y
              };

              this.view.hitTest(screenPoint).then((response) => {
                const graphics = response.results?.filter(result => 
                  result.graphic.layer === this.pointsLayer
                );

                if (graphics && graphics.length > 0) {
                  const point = [graphics[0].graphic.geometry.longitude, graphics[0].graphic.geometry.latitude];
                  this.includePoints = this.includePoints.filter(p => 
                    Math.abs(p[0] - point[0]) > 0.0000001 || Math.abs(p[1] - point[1]) > 0.0000001
                  );
                  this.excludePoints = this.excludePoints.filter(p => 
                    Math.abs(p[0] - point[0]) > 0.0000001 || Math.abs(p[1] - point[1]) > 0.0000001
                  );
                  this.updatePointsGraphics();
                }
              });
            } else if (this.currentMode) {
              // Add point logic
              const mapPoint = this.view.toMap({x: event.x, y: event.y});
              const point = [mapPoint.longitude, mapPoint.latitude];
              
              if (this.currentMode === 'include') {
                this.includePoints.push(point);
              } else {
                this.excludePoints.push(point);
              }
              this.updatePointsGraphics();
            }
          });

          // Points detect button
          this.panel.querySelector('#points-detect').addEventListener('click', async () => {
            if (this.includePoints.length === 0) {
              alert('Please add at least one include point');
              return;
            }

            const detectButton = this.panel.querySelector('#points-detect');
            try {
              detectButton.classList.add('loading');
              detectButton.disabled = true;

              const requestBody = {
                zoom_level: parseInt(this.panel.querySelector('#points-zoom-level').value),
                box_threshold: parseFloat(this.panel.querySelector('#points-box-threshold').value),
                points_include: this.includePoints,
                points_exclude: this.excludePoints
              };

              const response = await fetch('http://localhost:8001/api/v1/predict/points', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
              });

              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }

              const result = await response.json();
              this.displayPointsDetectionResult(result);

            } catch (error) {
              console.error('Error:', error);
              alert('Error during detection: ' + error.message);
            } finally {
              detectButton.classList.remove('loading');
              detectButton.disabled = false;
            }
          });

          // Points reset button
          this.panel.querySelector('#points-reset').addEventListener('click', () => {
            this.resetPointsSettings();
          });

          // Point mode buttons
          this.panel.querySelector('#includeMode').addEventListener('click', () => {
            if (this.deleteMode) {
              this.deleteMode = false;
            }
            this.currentMode = this.currentMode === 'include' ? null : 'include';
            updateButtonStates();
            this.view.cursor = this.currentMode ? "crosshair" : "default";
          });

          this.panel.querySelector('#excludeMode').addEventListener('click', () => {
            if (this.deleteMode) {
              this.deleteMode = false;
            }
            this.currentMode = this.currentMode === 'exclude' ? null : 'exclude';
            updateButtonStates();
            this.view.cursor = this.currentMode ? "crosshair" : "default";
          });

          this.panel.querySelector('#deleteMode').addEventListener('click', () => {
            this.deleteMode = !this.deleteMode;
            if (this.deleteMode) {
              this.currentMode = null;
              this.view.cursor = "not-allowed";
            } else {
              this.view.cursor = "default";
            }
            updateButtonStates();
          });
        }

        show() {
          this.panel.style.display = 'block';
          this.panelVisible = true;
        }

        hide() {
          this.panel.style.display = 'none';
          this.panelVisible = false;
          this.detectionParameters.geometry = null;
          this.detectionParameters.layer.removeAll();
          document.querySelector('#toolButton').textContent = "Activate Object Detection Tool";
          document.querySelector('#sketch_container').innerHTML = '';
        }

        toggle() {
          if (this.panelVisible) {
            this.hide();
          } else {
            this.show();
          }
        }

        async handleDetect() {
          const bbox = this.detectionParameters?.geometry?.extent;
          if (!this.zoomLevel || !this.textPrompt || !bbox) {
            alert('Please draw a rectangle and enter detection parameters');
            return;
          }

          const detectButton = this.panel.querySelector('#detect-btn');
          try {
            detectButton.classList.add('loading');
            detectButton.disabled = true;

            const boundingBox = convertBoundingBoxToGeographic(extentToBoundingBox(bbox));

            const requestBody = {
              "bounding_box": boundingBox,
              "text_prompt": this.textPrompt,
              "zoom_level": this.zoomLevel,
              "box_threshold": this.boxThreshold,
              "text_threshold": this.textThreshold,
            };

            await this.sendRequest(requestBody);

          } catch (error) {
            throw error;
          } finally {
            detectButton.classList.remove('loading');
            detectButton.disabled = false;
          }
        }

        resetSettings() {
          this.boxThreshold = 0.24;
          this.textThreshold = 0.24;
          this.opacity = 0.9;
          this.color = '#3333CC';

          // Update UI elements
          this.panel.querySelector('#box-threshold').value = this.boxThreshold;
          this.panel.querySelector('#box-threshold-value').textContent = this.boxThreshold.toFixed(2);
          this.panel.querySelector('#text-threshold').value = this.textThreshold;
          this.panel.querySelector('#text-threshold-value').textContent = this.textThreshold.toFixed(2);
          this.panel.querySelector('#opacity').value = this.opacity;
          this.panel.querySelector('#opacity-value').textContent = this.opacity.toFixed(1);
          this.panel.querySelector('#color-picker').value = this.color;

          if (this.geoJsonData) {
            this.updateGeoJsonStyle();
          }
        }

        updateGeoJsonStyle() {
          if (!this.editableLayer) {
            return;
          }

          // Update the renderer of the feature layer
          this.editableLayer.renderer = {
            type: "simple",
            symbol: this.displayMode === 'segments' ? {
              type: "simple-fill",
              color: [
                parseInt(this.color.slice(1, 3), 16),
                parseInt(this.color.slice(3, 5), 16),
                parseInt(this.color.slice(5, 7), 16),
                this.opacity
              ],
              style: "solid",
              outline: {
                color: "white",
                width: 1
              }
            } : {
              type: "simple-marker",
              style: "circle",
              color: [
                parseInt(this.color.slice(1, 3), 16),
                parseInt(this.color.slice(3, 5), 16),
                parseInt(this.color.slice(5, 7), 16),
                this.opacity
              ],
              size: "12px",
              outline: {
                color: "white",
                width: 1
              }
            }
          };
        }

        updateDisplay() {
          const graphicsLayer = this.detectionParameters.layer;
          graphicsLayer.removeAll();

          // Create appropriate FeatureLayer based on display mode
          const featureLayer = new FeatureLayer({
            source: [], // Start with empty source
            title: "Detection Result",
            objectIdField: "objectid",
            fields: [
              {
                name: "objectid",
                type: "oid"
              },
              {
                name: "value",
                type: "string"
              }
            ],
            renderer: this.displayMode === 'segments' ? 
              // Polygon renderer
              {
                type: "simple",
                symbol: {
                  type: "simple-fill",
                  color: [
                    parseInt(this.color.slice(1, 3), 16),
                    parseInt(this.color.slice(3, 5), 16),
                    parseInt(this.color.slice(5, 7), 16),
                    this.opacity
                  ],
                  style: "solid",
                  outline: {
                    color: "white",
                    width: 1
                  }
                }
              } :
              // Point renderer
              {
                type: "simple",
                symbol: {
                  type: "simple-marker",
                  style: "circle",
                  color: [
                    parseInt(this.color.slice(1, 3), 16),
                    parseInt(this.color.slice(3, 5), 16),
                    parseInt(this.color.slice(5, 7), 16),
                    this.opacity
                  ],
                  size: "12px",
                  outline: {
                    color: "white",
                    width: 1
                  }
                }
              },
            geometryType: this.displayMode === 'segments' ? "polygon" : "point",
            popupTemplate: {
              title: "{value}",
              content: this.displayMode === 'segments' ? 
                "Polygon Area: {value}" : 
                "Point Location: {value}"
            }
          });

          // Add features to the layer
          if (this.displayMode === 'segments') {
            // Display polygons
            const features = this.geoJsonData.features.map((feature, index) => {
              return {
                geometry: {
                  type: "polygon",
                  rings: feature.geometry.coordinates[0],
                  spatialReference: { wkid: 4326 }
                },
                attributes: {
                  objectid: index + 1,
                  value: feature.properties.value || 'Unknown'
                }
              };
            });

            featureLayer.applyEdits({
              addFeatures: features
            });
          } else if (this.displayMode === 'centroids') {
            // Display centroids
            const features = this.geoJsonData.features.map((feature, index) => {
              const coordinates = feature.geometry.coordinates[0];
              const centroid = this.calculateCentroid(coordinates);

              return {
                geometry: {
                  type: "point",
                  longitude: centroid[0],
                  latitude: centroid[1],
                  spatialReference: { wkid: 4326 }
                },
                attributes: {
                  objectid: index + 1,
                  value: feature.properties.value || 'Unknown'
                }
              };
            });

            featureLayer.applyEdits({
              addFeatures: features
            });
          }

          // Remove old layer if exists
          if (this.editableLayer) {
            map.remove(this.editableLayer);
          }

          // Add new layer to map
          map.add(featureLayer);
          this.editableLayer = featureLayer;

          // Update the Editor widget's layers
          editor.layerInfos = [{
            layer: featureLayer,
            enabled: true,
            addEnabled: true,
            updateEnabled: true,
            deleteEnabled: true
          }];
        }

        calculateCentroid(coordinates) {
          let sumX = 0;
          let sumY = 0;
          const len = coordinates.length - 1; // Subtract 1 because in polygons, last point equals first point

          for (let i = 0; i < len; i++) {
            sumX += coordinates[i][0];
            sumY += coordinates[i][1];
          }

          return [sumX / len, sumY / len];
        }

        updatePointsStyle() {
          this.pointsLayer.removeAll();
          
          // Add include points (green)
          this.includePoints.forEach(coords => {
            const point = {
              type: "point",
              longitude: coords[0],
              latitude: coords[1]
            };
            
            const markerSymbol = {
              type: "simple-marker",
              style: "circle",
              color: [0, 255, 0, 0.8],  // Green
              size: "12px",
              outline: {
                color: [255, 255, 255, 0.8],
                width: 2
              }
            };
            
            const graphic = new Graphic({
              geometry: point,
              symbol: markerSymbol
            });
            
            this.pointsLayer.add(graphic);
          });

          // Add exclude points (red)
          this.excludePoints.forEach(coords => {
            const point = {
              type: "point",
              longitude: coords[0],
              latitude: coords[1]
            };
            
            const markerSymbol = {
              type: "simple-marker",
              style: "circle",
              color: [255, 0, 0, 0.8],  // Red
              size: "12px",
              outline: {
                color: [255, 255, 255, 0.8],
                width: 2
              }
            };
            
            const graphic = new Graphic({
              geometry: point,
              symbol: markerSymbol
            });
            
            this.pointsLayer.add(graphic);
          });
        }

        updatePointsDisplay() {
          const graphicsLayer = this.detectionParameters.layer;
          graphicsLayer.removeAll();

          // Create appropriate FeatureLayer based on display mode
          const featureLayer = new FeatureLayer({
            source: [], // Start with empty source
            objectIdField: "objectid",
            fields: [
              {
                name: "objectid",
                type: "oid"
              },
              {
                name: "value",
                type: "string"
              }
            ],
            renderer: this.pointsDisplayMode === 'segments' ? 
              // Polygon renderer
              {
                type: "simple",
                symbol: {
                  type: "simple-fill",
                  color: [
                    parseInt(this.pointsColor.slice(1, 3), 16),
                    parseInt(this.pointsColor.slice(3, 5), 16),
                    parseInt(this.pointsColor.slice(5, 7), 16),
                    this.pointsOpacity
                  ],
                  outline: {
                    color: "white",
                    width: 1
                  }
                }
              } :
              // Point renderer
              {
                type: "simple",
                symbol: {
                  type: "simple-marker",
                  style: "circle",
                  color: [
                    parseInt(this.pointsColor.slice(1, 3), 16),
                    parseInt(this.pointsColor.slice(3, 5), 16),
                    parseInt(this.pointsColor.slice(5, 7), 16),
                    this.pointsOpacity
                  ],
                  size: "12px",
                  outline: {
                    color: "white",
                    width: 1
                  }
                }
              },
            geometryType: this.pointsDisplayMode === 'segments' ? "polygon" : "point",
            popupTemplate: {
              title: "Detection Result",
              content: "{*}"
            }
          });

          // Add features to the layer
          if (this.pointsDisplayMode === 'segments') {
            // Display polygons
            const features = this.geoJsonData.features.map((feature, index) => {
              return {
                geometry: {
                  type: "polygon",
                  rings: feature.geometry.coordinates[0],
                  spatialReference: { wkid: 4326 }
                },
                attributes: {
                  objectid: index + 1,
                  value: feature.properties.value || 'Unknown'
                }
              };
            });

            featureLayer.applyEdits({
              addFeatures: features
            });
          } else if (this.pointsDisplayMode === 'centroids') {
            // Display centroids
            const features = this.geoJsonData.features.map((feature, index) => {
              const coordinates = feature.geometry.coordinates[0];
              const centroid = this.calculateCentroid(coordinates);

              return {
                geometry: {
                  type: "point",
                  longitude: centroid[0],
                  latitude: centroid[1],
                  spatialReference: { wkid: 4326 }
                },
                attributes: {
                  objectid: index + 1,
                  value: feature.properties.value || 'Unknown'
                }
              };
            });

            featureLayer.applyEdits({
              addFeatures: features
            });
          }

          // Remove old layer if exists
          if (this.editableLayer) {
            map.remove(this.editableLayer);
          }

          // Add new layer to map
          map.add(featureLayer);
          this.editableLayer = featureLayer;

          // Update the Editor widget's layers
          editor.layerInfos = [{
            layer: featureLayer,
            enabled: true,
            addEnabled: true,
            updateEnabled: true,
            deleteEnabled: true
          }];
        }

        displayPointsDetectionResult(geojson) {
          // Save the geojson data for later use
          this.geoJsonData = geojson;

          // Remove old layer if exists
          if (this.editableLayer) {
            this.view.map.remove(this.editableLayer);
          }

          const graphics = geojson.features.map(feature => {
            return new Graphic({
              geometry: {
                type: this.pointsDisplayMode === 'segments' ? "polygon" : "point",
                rings: this.pointsDisplayMode === 'segments' ? feature.geometry.coordinates[0] : undefined,
                longitude: this.pointsDisplayMode === 'centroids' ? this.calculateCentroid(feature.geometry.coordinates[0])[0] : undefined,
                latitude: this.pointsDisplayMode === 'centroids' ? this.calculateCentroid(feature.geometry.coordinates[0])[1] : undefined,
                spatialReference: { wkid: 4326 }
              },
              attributes: feature.properties
            });
          });

          const featureLayer = new FeatureLayer({
            source: graphics,
            title: "Points Detection Result",
            objectIdField: "OBJECTID",
            fields: [
              {
                name: "OBJECTID",
                type: "oid"
              },
              {
                name: "value",
                type: "string"
              }
            ],
            renderer: {
              type: "simple",
              symbol: this.pointsDisplayMode === 'segments' ? {
                type: "simple-fill",
                color: [
                  parseInt(this.pointsColor.slice(1, 3), 16),
                  parseInt(this.pointsColor.slice(3, 5), 16),
                  parseInt(this.pointsColor.slice(5, 7), 16),
                  this.pointsOpacity
                ],
                outline: {
                  color: "white",
                  width: 1
                }
              } : {
                type: "simple-marker",
                style: "circle",
                color: [
                  parseInt(this.pointsColor.slice(1, 3), 16),
                  parseInt(this.pointsColor.slice(3, 5), 16),
                  parseInt(this.pointsColor.slice(5, 7), 16),
                  this.pointsOpacity
                ],
                size: "12px",
                outline: {
                  color: "white",
                  width: 1
                }
              }
            },
            popupTemplate: {
              title: "Detection Result",
              content: "{*}"
            }
          });

          this.view.map.add(featureLayer);
          this.editableLayer = featureLayer;

          // Update event listeners for points display options
          const pointsDisplayModeInputs = this.panel.querySelectorAll('input[name="points-display-mode"]');
          pointsDisplayModeInputs.forEach(input => {
            input.addEventListener('change', (e) => {
              this.pointsDisplayMode = e.target.value;
              this.updatePointsDetectionDisplay();
            });
          });

          // Update event listeners for points style options
          const pointsOpacityInput = this.panel.querySelector('#points-opacity');
          pointsOpacityInput.addEventListener('input', (e) => {
            this.pointsOpacity = parseFloat(e.target.value);
            this.updatePointsDetectionStyle();
          });

          const pointsColorPicker = this.panel.querySelector('#points-color-picker');
          pointsColorPicker.addEventListener('input', (e) => {
            this.pointsColor = e.target.value;
            this.updatePointsDetectionStyle();
          });
        }

        updatePointsDetectionStyle() {
          if (!this.editableLayer) return;

          this.editableLayer.renderer = {
            type: "simple",
            symbol: this.pointsDisplayMode === 'segments' ? {
              type: "simple-fill",
              color: [
                parseInt(this.pointsColor.slice(1, 3), 16),
                parseInt(this.pointsColor.slice(3, 5), 16),
                parseInt(this.pointsColor.slice(5, 7), 16),
                this.pointsOpacity
              ],
              outline: {
                color: "white",
                width: 1
              }
            } : {
              type: "simple-marker",
              style: "circle",
              color: [
                parseInt(this.pointsColor.slice(1, 3), 16),
                parseInt(this.pointsColor.slice(3, 5), 16),
                parseInt(this.pointsColor.slice(5, 7), 16),
                this.pointsOpacity
              ],
              size: "12px",
              outline: {
                color: "white",
                width: 1
              }
            }
          };
        }

        updatePointsDetectionDisplay() {
          if (!this.geoJsonData) return;
          this.displayPointsDetectionResult(this.geoJsonData);
        }

        resetPointsSettings() {
          this.includePoints = [];
          this.excludePoints = [];
          this.pointsLayer.removeAll();
          this.pointsColor = '#3333CC';
          this.pointsOpacity = 0.9;
          
          // Reset UI elements
          this.panel.querySelector('#points-zoom-level').value = "22";
          this.panel.querySelector('#points-box-threshold').value = "0.24";
          this.panel.querySelector('#points-box-threshold').nextElementSibling.value = "0.24";
          this.panel.querySelector('#points-opacity').value = this.pointsOpacity;
          this.panel.querySelector('#points-opacity-value').textContent = this.pointsOpacity.toFixed(1);
          this.panel.querySelector('#points-color-picker').value = this.pointsColor;
        }

        updatePointsGraphics() {
          if (!this.pointsLayer) return;
          
          this.pointsLayer.removeAll();
          
          // Add include points (green)
          this.includePoints.forEach(coords => {
            const point = {
              type: "point",
              longitude: coords[0],
              latitude: coords[1]
            };
            
            const markerSymbol = {
              type: "simple-marker",
              style: "circle",
              color: [0, 255, 0, 0.8],  // Green
              size: "12px",
              outline: {
                color: [255, 255, 255, 0.8],
                width: 2
              }
            };
            
            const graphic = new Graphic({
              geometry: point,
              symbol: markerSymbol
            });
            
            this.pointsLayer.add(graphic);
          });

          // Add exclude points (red)
          this.excludePoints.forEach(coords => {
            const point = {
              type: "point",
              longitude: coords[0],
              latitude: coords[1]
            };
            
            const markerSymbol = {
              type: "simple-marker",
              style: "circle",
              color: [255, 0, 0, 0.8],  // Red
              size: "12px",
              outline: {
                color: [255, 255, 255, 0.8],
                width: 2
              }
            };
            
            const graphic = new Graphic({
              geometry: point,
              symbol: markerSymbol
            });
            
            this.pointsLayer.add(graphic);
          });
        }
      };

      let objectDetectionPanel;
      let detectionLayer = new GraphicsLayer();
      let detectionParameters = {
        layer: detectionLayer,
      };
      map.add(detectionLayer);

      objectDetectionPanel = new ObjectDetectionPanel(view, detectionParameters, sendObjectDetectionRequest);

      // Update tool button click handler
      toolButton.addEventListener("click", () => {
        let toolActive = (toolButton.textContent === "Activate Object Detection Tool");
        toolButton.textContent = toolActive ? "Deactivate Tool" : "Activate Object Detection Tool";
        let sketch;
        if (toolActive) {
          objectDetectionPanel.show();
          sketch = new Sketch({
            layer: detectionLayer,
            view: view,
            container: "sketch_container",
            availableCreateTools: ["rectangle"],
            visibleElements: {
              selectionTools: {
                "lasso-selection": false,
                "rectangle-selection": false,
              },
              settingsMenu: false,
              undoRedoMenu: false,
            },
          });
          sketch.on('create', (event) => {
            if (event.state === 'start') {
              detectionParameters.geometry = null;
              detectionLayer.removeAll();
            }
            if (event.state === 'complete') {
              detectionParameters.geometry = event.graphic.geometry;
            }
          });
        } else {
          objectDetectionPanel.hide();
          view.ui.remove(sketch);
          detectionLayer.removeAll();
          detectionParameters.geometry = null;
        }
      });

      const sectionsLayer = new FeatureLayer({
        url: 'https://services3.arcgis.com/hm7m5CL2bomXg0YW/ArcGIS/rest/services/drone_poc_Arcgispro_WFL1/FeatureServer/6'
      });
      const parcelsLayer = new FeatureLayer({
        url: 'https://services3.arcgis.com/hm7m5CL2bomXg0YW/ArcGIS/rest/services/drone_poc_Arcgispro_WFL1/FeatureServer/0'
      });
      const addressLayer = new TileLayer({
        url: 'https://tiles.arcgis.com/tiles/hm7m5CL2bomXg0YW/arcgis/rest/services/Tile_Cache_CRH_1/MapServer/0'
      });
      const peLayer = new FeatureLayer({
        url: 'https://services3.arcgis.com/hm7m5CL2bomXg0YW/ArcGIS/rest/services/drone_poc_Arcgispro_WFL1/FeatureServer/7'
      });
      const lineLayer = new FeatureLayer({
        url: 'https://gisservices.its.ny.gov/arcgis/rest/services/NYS_Streets/MapServer/4'
      });
      const gicToken = 'e8823ec887551f759d7dbd14df3194333bbdedce22a4cb0315448aae1670f15717adf3947f1bd8a3e9d0abd5b14b0739165e8de570cdf0009b8fe983bd6b4653';
      const core = new Vexcel.Map({
        target: "vexcelMap",
        token: gicToken,
        init: {
          layers: false,
          callback: () => {
            core.getLayerManager().getVexcelLayer(Vexcel.Constants.BuiltInLayers.BLUESKY).setVisible(true);
          },
        },
      });

      async function displayGeojsonData(geoJson) {
        objectDetectionPanel.geoJsonData = geoJson;
        objectDetectionPanel.updateDisplay();
      }

      async function sendObjectDetectionRequest(requestBody) {
        const myHeaders = new Headers();
        myHeaders.append("Content-Type", "application/json");

        const raw = JSON.stringify(requestBody);

        const requestOptions = {
          method: "POST",
          headers: myHeaders,
          body: raw,
          redirect: "follow"
        };

        const response = await fetch("http://localhost:8001/api/v1/predict/text", requestOptions);
        if (!response.ok) {
          throw new Error("Network response was not ok while sending object detection request.");
        }
        const geojson = await response.json();
        displayGeojsonData(geojson);
      }

      async function object_detection(event) {
        const imageSize = 300;
        const point = view.toMap(event);
        const screenshot = await view.takeScreenshot({
          width: imageSize,
          height: imageSize
        });
        const blob = await fetch(screenshot.dataUrl).then(res => res.blob());
        const formData = new FormData();
        formData.append("image", blob, "map_image.jpeg");
        fetch("https://api.api-ninjas.com/v1/objectdetection", {
          method: "POST",
          body: formData,
          headers: {
            "X-Api-Key": "xroen1siNMHHcz+acUlmsw==Fk1cAOytmzSan5GV"
          }
        })
          .then(response => response.json())
          .then(data => {
            console.log(data);
            detectionLayer.removeAll();
            const bounding_box_to_center_point = (event, bounding_box) => {
              const { x1, y1, x2, y2 } = bounding_box;
              const centerX = (parseFloat(x1) + parseFloat(x2)) / 2;
              const centerY = (parseFloat(y1) + parseFloat(y2)) / 2;
              const screenPoint = {
                x: event.screenPoint.x,
                y: event.screenPoint.y,
              };
              const topLeftPoint = {
                x: screenPoint.x - imageSize / 2,
                y: screenPoint.y - imageSize / 2,
              };
              const relativePoint = {
                x: centerX - (topLeftPoint.x - screenPoint.x),
                y: centerY - (topLeftPoint.y - screenPoint.y),
              };
              const mapPoint = view.toMap({
                x: relativePoint.x,
                y: relativePoint.y
              });
              return mapPoint;
            };
            const allowedLabels = ["car", "pole", "potted plant", "bus", "truck", "manhole"];
            const rightPanel = document.getElementById('rightPanel');
            rightPanel.innerHTML = '<span><b>Work Order Network Elements</b></span><br/>';
            data.forEach((item) => {
              const { label, bounding_box } = item;
              if (allowedLabels.includes(label)) {
                const mapPoint = bounding_box_to_center_point(event, bounding_box);
                const mapCRS = 'EPSG:4326';
                const [x, y] = [mapPoint.x, mapPoint.y];
                const graphic = new Graphic({
                  geometry: {
                    type: "point",
                    x: x,
                    y: y,
                    spatialReference: { wkid: mapCRS }
                  },
                  symbol: {
                    type: "text",
                    color: "red",
                    text: label,
                    font: { size: 12, family: "sans-serif" },
                    haloColor: "white",
                    haloSize: "1px"
                  }
                });
                const projectedPoints = projection.project(graphic, mapCRS);
                detectionLayer.add(projectedPoints);
                if (rightPanel) {
                  const labelElement = document.createElement('div');
                  labelElement.innerHTML = `<strong>${label}</strong>: (${x.toFixed(2)}, ${y.toFixed(2)})`;
                  labelElement.style.marginBottom = '8px';
                  rightPanel.appendChild(labelElement);
                }
              }
            });
          })
          .catch(error => {
            console.error("Error:", error);
            alert("Error");
          });
      }
      view.on("click", async (event) => {
        object_detection(event);
        var e = document.getElementById("3dSelect");
        var value = e.options[e.selectedIndex].value;
        if (value == "3D ON") {
          const latitude = event.mapPoint.latitude;
          const longitude = event.mapPoint.longitude;
          const zoom = view.zoom;
          core.setZoom(19);
          core.setLocation(new Vexcel.Geometry.Location(latitude, longitude));
          changeMode('3D');
          showVexcelMap();
          core.addEventListener(Vexcel.Events.MapEvents.START_MEASURE, (evt) => {
            console.log(`MeasurementInfo Start: ${JSON.stringify(evt.measure.toGeoJSON())}`);
          });
          core.addEventListener(Vexcel.Events.MapEvents.FINISH_MEASURE, (evt) => {
            console.log(`MeasurementInfo Finish: ${JSON.stringify(evt.measure.toGeoJSON())}`);
          });
          core.addEventListener(Vexcel.Events.MapEvents.CHANGE_MEASURE, (evt) => {
            console.log(`MeasurementInfo Change: ${JSON.stringify(evt.measure.getMeasurementInfo())}`);
          });
          core.addEventListener(Vexcel.Events.MapEvents.STATUS_3D_MEASURES, (evt) => {
            console.log(`3D Measure availability status:${evt.status} inside:${evt.inside}`);
            if (evt.status === Vexcel.Constants.Status3D.STOP) {
              document.getElementById("status-3d").className = "badge";
              document.getElementById("status-3d").textContent = "NO DATA";
            }
            if (evt.status === Vexcel.Constants.Status3D.DOWNLOADING) {
              document.getElementById("status-3d").className = "badge download";
              document.getElementById("status-3d").textContent = "DOWNLOAD";
            }
            if (evt.status === Vexcel.Constants.Status3D.FINISHED && evt.inside) {
              document.getElementById("status-3d").className = "badge available";
              document.getElementById("status-3d").textContent = "AVAILABLE";
            }
            if (evt.status === Vexcel.Constants.Status3D.FINISHED && !evt.inside) {
              document.getElementById("status-3d").className = "badge";
              document.getElementById("status-3d").textContent = "NO DATA";
            }
          });
        }
      });
      function changeMode(mode) {
        core.changeMode(mode)
          .then((response) => {
            console.log(response.msg);
            if (response.layer) {
              console.log(`Change to mode ${mode} for layer ${response.layer.getName()}`);
            }
          })
          .catch((error) => {
            console.log(error);
            alert(error);
          });
      }
      function changeOrientation(orientation) {
        core.changeOrientation(orientation)
          .then((response) => {
            console.log(response.msg);
          })
          .catch((error) => {
            console.log(error);
            alert(error);
          });
      }
      map.addMany([sectionsLayer, parcelsLayer, addressLayer, peLayer, lineLayer]);
      const layerList = new LayerList({
        view: view
      });
      view.ui.add(layerList, {
        position: "bottom-left"
      });
      function hideVexcelMap() {
        var div = document.getElementById('vexcelMapContainer');
        div.style.visibility = "hidden";
      }
      function showVexcelMap() {
        var div = document.getElementById('vexcelMapContainer');
        div.style.visibility = "visible";
      }
      document.getElementById('verticalBtn').onclick = function () { changeOrientation('V'); };
      document.getElementById('northBtn').onclick = function () { changeOrientation('N'); };
      document.getElementById('southBtn').onclick = function () { changeOrientation('S'); };
      document.getElementById('eastBtn').onclick = function () { changeOrientation('E'); };
      document.getElementById('westBtn').onclick = function () { changeOrientation('W'); };
      document.getElementById('closeBtn').onclick = function () { hideVexcelMap(); };
      document.getElementById("point").addEventListener("click", () => {
        core.getMeasurementManager().activate(Vexcel.Constants.MeasurementTools.POINT);
      });
      document.getElementById("line").addEventListener("click", () => {
        core.getMeasurementManager().activate(Vexcel.Constants.MeasurementTools.LINE);
      });
      document.getElementById("polygon").addEventListener("click", () => {
        core.getMeasurementManager().activate(Vexcel.Constants.MeasurementTools.POLYGON);
      });
      document.getElementById("rectangle").addEventListener("click", () => {
        core.getMeasurementManager().activate(Vexcel.Constants.MeasurementTools.RECTANGLE);
      });
      document.getElementById("circle").addEventListener("click", () => {
        core.getMeasurementManager().activate(Vexcel.Constants.MeasurementTools.CIRCLE);
      });
      document.getElementById("dragBtn").addEventListener("click", () => {
        core.getMeasurementManager().activate(Vexcel.Constants.MeasurementTools.DRAG);
      });
      function geocodeExtent(extent) {
        const requestOptions = {
          method: "GET",
          redirect: "follow"
        };
        const center = webMercatorUtils.webMercatorToGeographic(extent.center);
        console.log(center);
        const url = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${center.y},${center.x}&key=AIzaSyDhhixURX0PrrAsVzodk5q5QuiIhg7dwu0`;
        fetch(url, requestOptions)
          .then(response => response.json())
          .then(result => {
            if (result.status === "OK") {
              result.results.forEach(location => {
                var point = {
                  type: "point",
                  longitude: location.geometry.location.lng,
                  latitude: location.geometry.location.lat
                };
                var markerSymbol = {
                  type: "simple-marker",
                  color: [226, 119, 40],
                  outline: {
                    color: [255, 255, 255],
                    width: 2
                  }
                };
                var pointGraphic = new Graphic({
                  geometry: point,
                  symbol: markerSymbol
                });
                graphicsLayer.add(pointGraphic);
                console.log(point);
                var textSymbol = {
                  type: "text",
                  color: "black",
                  haloColor: "white",
                  haloSize: "1px",
                  text: location.formatted_address,
                  xoffset: 0,
                  yoffset: -20,
                  font: {
                    size: 12,
                    family: "sans-serif"
                  }
                };
                var textGraphic = new Graphic({
                  geometry: point,
                  symbol: textSymbol
                });
                graphicsLayer.add(textGraphic);
              });
            } else {
              console.error("Geocode was not successful for the following reason: " + result.status);
            }
          })
          .catch(error => console.error("Error:", error));
      }
      document.getElementById("geocodeButton").addEventListener("click", function () {
        graphicsLayer.removeAll();
        geocodeExtent(view.extent);
      });
    });

    /**
     * Converts an Esri Extent object to a bounding box array
     * @param {Object} extent - Esri Extent object containing xmin, ymin, xmax, ymax
     * @returns {Array} Bounding box array in [west, south, east, north] format
     */
    function extentToBoundingBox(extent) {
      // Input validation
      if (!extent || typeof extent !== 'object') {
        throw new Error('Invalid extent object');
      }

      // Check if required properties exist
      if (!('xmin' in extent) || !('ymin' in extent) ||
        !('xmax' in extent) || !('ymax' in extent)) {
        throw new Error('Extent object missing required properties');
      }

      // Convert to bounding box format [west, south, east, north]
      return [
        extent.xmin,  // west
        extent.ymin,  // south
        extent.xmax,  // east
        extent.ymax   // north
      ];
    }

    /**
     * Converts Web Mercator coordinates to Geographic coordinates (lat/long)
     * @param {number} x - Web Mercator X coordinate
     * @param {number} y - Web Mercator Y coordinate
     * @returns {Array} Array containing [longitude, latitude]
     */
    function webMercatorToGeographic(x, y) {
      // Earth's radius in meters
      const EARTH_RADIUS = 6378137;

      // Convert X coordinate to longitude
      const longitude = (x / EARTH_RADIUS) * (180 / Math.PI);

      // Convert Y coordinate to latitude
      const latitude = (Math.PI / 2 - 2 * Math.atan(Math.exp(-y / EARTH_RADIUS))) * (180 / Math.PI);

      return [longitude, latitude];
    }

    /**
    * Converts Web Mercator bounding box to Geographic bounding box
    * @param {Array} bbox - Bounding box in Web Mercator [west, south, east, north]
    * @returns {Array} Bounding box in Geographic coordinates [west, south, east, north]
    */
    function convertBoundingBoxToGeographic(bbox) {
      // Convert southwest corner
      const [westLong, southLat] = webMercatorToGeographic(bbox[0], bbox[1]);

      // Convert northeast corner
      const [eastLong, northLat] = webMercatorToGeographic(bbox[2], bbox[3]);

      // Return in [west, south, east, north] format
      return [westLong, southLat, eastLong, northLat];
    }

  </script>
</body>

</html>